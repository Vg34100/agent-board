<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Tauri + Leptos App</title>
    <link data-trunk rel="css" href="styles.css" />
    <link data-trunk rel="copy-dir" href="public" />
    <link data-trunk rel="rust" data-wasm-opt="z" />
    <script>
      (function() {
        // Suppress Trunk dev server WebSocket connection errors
        const originalConsoleError = console.error;
        console.error = function(...args) {
          const message = args.join(' ');
          // Suppress WebSocket connection errors from Trunk dev server
          if (message.includes('WebSocket connection') && 
              (message.includes('{{__trunk_address__}}') || message.includes('{{__trunk_ws_base__}}'))) {
            return; // Silently ignore these development artifacts
          }
          // Suppress net::ERR_NAME_NOT_RESOLVED for Trunk WebSocket
          if (message.includes('net::ERR_NAME_NOT_RESOLVED') && message.includes('trunk')) {
            return;
          }
          originalConsoleError.apply(console, args);
        };
        
        // Decide transport based on page origin. If we're on http(s), prefer HTTP + SSE even inside Tauri.
        const isHttp = (location.protocol === 'http:' || location.protocol === 'https:');
        let hasNativeInvoke = false;
        try {
          hasNativeInvoke = !!(window.__TAURI__ && window.__TAURI__.core && typeof window.__TAURI__.core.invoke === 'function');
        } catch (_) {}
        
        // If we're not on http(s) (i.e., tauri:// asset), and native invoke exists, use native and exit early.
        if (!isHttp && hasNativeInvoke) {
          return;
        }
        
        // Ensure namespace exists
        window.__TAURI__ = window.__TAURI__ || {};
        
        function safeSerialize(obj) {
          try {
            // Handle null/undefined
            if (obj === null || obj === undefined) {
              return {};
            }
            
            // Handle strings (might be JSON)
            if (typeof obj === 'string') {
              try {
                return JSON.parse(obj);
              } catch {
                return obj;
              }
            }
            
            // Handle primitives
            if (typeof obj !== 'object') {
              return obj;
            }
            
            // Handle special objects
            if (obj instanceof Map) {
              return Object.fromEntries(Array.from(obj.entries()));
            }
            if (obj instanceof Set) {
              return Array.from(obj);
            }
            if (obj instanceof Date) {
              return obj.toISOString();
            }
            
            // Handle regular objects and arrays - try direct JSON.stringify first
            try {
              const jsonString = JSON.stringify(obj);
              if (jsonString === '{}' && Object.keys(obj).length > 0) {
                console.error('JSON.stringify produced empty object for:', obj);
                // Fallback: manually construct object
                if (Array.isArray(obj)) {
                  return obj.map(item => safeSerialize(item));
                } else {
                  const result = {};
                  for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                      result[key] = safeSerialize(obj[key]);
                    }
                  }
                  return result;
                }
              }
              return JSON.parse(jsonString);
            } catch (e) {
              console.error('JSON serialization failed for object:', obj, 'Error:', e);
              // Fallback: manually construct object
              if (Array.isArray(obj)) {
                return obj.map(item => safeSerialize(item));
              } else {
                const result = {};
                for (const key in obj) {
                  if (obj.hasOwnProperty(key)) {
                    try {
                      result[key] = safeSerialize(obj[key]);
                    } catch (e2) {
                      console.warn('Failed to serialize key', key, ':', e2);
                      result[key] = String(obj[key]);
                    }
                  }
                }
                return result;
              }
            }
          } catch (e) {
            console.error('Complete serialization failure for:', obj, e);
            return {};
          }
        }
        
        // Only provide an HTTP invoke shim if native invoke isn't available
        if (!hasNativeInvoke) {
          window.__TAURI__.core = {
            invoke: async function(cmd, args) {
            try {
              console.log('Browser invoke:', cmd, 'with args:', args);
              
              // Normalize arguments to a clean object
              const normalizedArgs = safeSerialize(args);
              console.log('Normalized args:', normalizedArgs);
              
              // Create a clean JSON string - bypass the problematic serialization
              let argsString;
              try {
                argsString = JSON.stringify(normalizedArgs);
                console.log('Args string:', argsString);
                
                // WASM Map Serialization Fix: Check if JSON.stringify produced empty objects for non-empty arrays
                if (argsString.includes('[{}')) {
                  console.warn('ðŸ” Detected potential WASM Map serialization issue - scanning arrays...');
                  
                  // Helper function to convert WASM Map objects to regular JavaScript objects
                  const convertMapToObject = (item, itemType) => {
                    const obj = {};
                    
                    if (item instanceof Map) {
                      // WASM objects are Maps - convert to regular object
                      for (const [key, value] of item.entries()) {
                        obj[key] = value;
                      }
                      console.log(`âœ… Converted ${itemType} Map to object:`, Object.keys(obj));
                      return obj;
                    } else {
                      // Try multiple methods to copy object properties
                      try {
                        // Method 1: for...in loop
                        for (const key in item) {
                          if (item.hasOwnProperty(key)) {
                            obj[key] = item[key];
                          }
                        }
                        
                        // Method 2: Object.keys as fallback
                        if (Object.keys(obj).length === 0) {
                          Object.keys(item).forEach(key => {
                            obj[key] = item[key];
                          });
                        }
                        
                        // Method 3: getOwnPropertyNames as last resort
                        if (Object.keys(obj).length === 0) {
                          Object.getOwnPropertyNames(item).forEach(key => {
                            obj[key] = item[key];
                          });
                        }
                      } catch (e) {
                        console.warn(`Failed to copy ${itemType} properties:`, e);
                      }
                    }
                    
                    return obj;
                  };
                  
                  let fixedArgs = {...normalizedArgs};
                  let wasFixed = false;
                  
                  // Check common array types that might contain WASM Maps
                  const arrayTypes = ['tasks', 'processes', 'projects', 'messages', 'settings'];
                  
                  arrayTypes.forEach(arrayType => {
                    if (normalizedArgs[arrayType] && Array.isArray(normalizedArgs[arrayType]) && normalizedArgs[arrayType].length > 0) {
                      // Check if this array has the empty object issue
                      const testJson = JSON.stringify(normalizedArgs[arrayType]);
                      if (testJson.includes('[{}') || testJson.includes(',{}')) {
                        console.log(`ðŸ”§ Fixing ${arrayType} array serialization...`);
                        fixedArgs[arrayType] = normalizedArgs[arrayType].map(item => 
                          convertMapToObject(item, arrayType.slice(0, -1)) // Remove 's' from plural
                        );
                        wasFixed = true;
                      }
                    }
                  });
                  
                  if (wasFixed) {
                    argsString = JSON.stringify(fixedArgs);
                    console.log('âœ… WASM Map serialization fixed');
                  }
                }
              } catch (e) {
                console.error('JSON.stringify failed:', e);
                argsString = '{}';
              }
              
              const payload = { 
                cmd, 
                args: normalizedArgs,
                args_string: argsString 
              };
              
              console.log('Sending payload:', payload);
              
              const res = await fetch('/api/invoke', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              
              if (!res.ok) {
                console.error('HTTP error:', res.status, res.statusText);
                return null;
              }
              
              const data = await res.json().catch(e => {
                console.error('JSON parse error:', e);
                return null;
              });
              
              console.log('Received response:', data);
              return data;
            } catch (e) {
              console.error('Invoke error:', e);
              return null;
            }
            }
          };
        }
        
        // SSE-based event system for HTTP clients (used whenever we're on http/https)
        window.__TAURI__.event = window.__TAURI__.event || {};
        
        // Global SSE connection and event handlers
        let sseConnection = null;
        const eventHandlers = new Map();
        
        // Initialize SSE connection
        function initializeSSE() {
          if (sseConnection) return; // Already connected
          
          console.log('ðŸ”— Initializing SSE connection to /api/events');
          sseConnection = new EventSource('/api/events');
          
          sseConnection.onopen = function() {
            console.log('âœ… SSE connection established');
          };
          
          sseConnection.onerror = function(error) {
            console.error('âŒ SSE connection error:', error);
            // Reconnect after delay
            setTimeout(() => {
              if (sseConnection.readyState === EventSource.CLOSED) {
                console.log('ðŸ”„ Reconnecting SSE...');
                sseConnection = null;
                initializeSSE();
              }
            }, 5000);
          };
          
          // Handle heartbeat events
          sseConnection.addEventListener('heartbeat', function(event) {
            console.log('ðŸ’“ SSE heartbeat:', event.data);
          });
          
          // Handle agent_message_update events
          sseConnection.addEventListener('agent_message_update', function(event) {
            console.log('ðŸ“¨ Received agent_message_update via SSE:', event.data);
            try {
              const eventData = JSON.parse(event.data);
              if (eventHandlers.has('agent_message_update')) {
                eventHandlers.get('agent_message_update').forEach(handler => {
                  handler({ payload: eventData.payload });
                });
              }
            } catch (e) {
              console.error('Failed to parse agent_message_update event:', e);
            }
          });
          
          // Handle agent_process_status events
          sseConnection.addEventListener('agent_process_status', function(event) {
            console.log('ðŸ“Š Received agent_process_status via SSE:', event.data);
            try {
              const eventData = JSON.parse(event.data);
              if (eventHandlers.has('agent_process_status')) {
                eventHandlers.get('agent_process_status').forEach(handler => {
                  handler({ payload: eventData.payload });
                });
              }
            } catch (e) {
              console.error('Failed to parse agent_process_status event:', e);
            }
          });
        }
        
        // Provide a stable global API that our app will call to avoid native permission issues
        // Always define it on http(s); it uses SSE under the hood and never touches native Tauri events
        if (isHttp) {
          window.AGENT_EVENT_LISTEN = async function(eventName, handler) {
            console.log(`ðŸŽ§ Setting up SSE listener for event: ${eventName}`);
          
          // Initialize SSE connection if needed
          if (!sseConnection) {
            initializeSSE();
          }
          
          // Store the handler
          if (!eventHandlers.has(eventName)) {
            eventHandlers.set(eventName, []);
          }
          eventHandlers.get(eventName).push(handler);
          
          // Return unlisten function
          return { 
            unlisten() {
              console.log(`ðŸ”‡ Unlistening from event: ${eventName}`);
              if (eventHandlers.has(eventName)) {
                const handlers = eventHandlers.get(eventName);
                const index = handlers.indexOf(handler);
                if (index !== -1) {
                  handlers.splice(index, 1);
                }
              }
            }
          };
          };
          
          // Also try to shadow native listen to help other callers, but our app will call AGENT_EVENT_LISTEN directly
          try {
            Object.defineProperty(window.__TAURI__.event, 'listen', {
              value: window.AGENT_EVENT_LISTEN,
              writable: false,
              configurable: false,
              enumerable: true
            });
          } catch (_) {
            // Fallback assignment if defineProperty fails
            window.__TAURI__.event.listen = window.AGENT_EVENT_LISTEN;
          }
        }
      })();
    </script>
  </head>
  <body></body>
</html>
