<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Tauri + Leptos App</title>
    <link data-trunk rel="css" href="styles.css" />
    <link data-trunk rel="copy-dir" href="public" />
    <link data-trunk rel="rust" data-wasm-opt="z" />
    <script>
      (function() {
        // Provide a browser shim for Tauri's invoke when running outside Tauri.
        try {
          if (window.__TAURI__ && window.__TAURI__.core && typeof window.__TAURI__.core.invoke === 'function') {
            return; // Tauri desktop/webview - use native invoke
          }
        } catch (_) {}
        window.__TAURI__ = window.__TAURI__ || {};
        
        function safeSerialize(obj) {
          try {
            // Handle null/undefined
            if (obj === null || obj === undefined) {
              return {};
            }
            
            // Handle strings (might be JSON)
            if (typeof obj === 'string') {
              try {
                return JSON.parse(obj);
              } catch {
                return obj;
              }
            }
            
            // Handle primitives
            if (typeof obj !== 'object') {
              return obj;
            }
            
            // Handle special objects
            if (obj instanceof Map) {
              return Object.fromEntries(Array.from(obj.entries()));
            }
            if (obj instanceof Set) {
              return Array.from(obj);
            }
            if (obj instanceof Date) {
              return obj.toISOString();
            }
            
            // Handle regular objects and arrays - try direct JSON.stringify first
            try {
              const jsonString = JSON.stringify(obj);
              if (jsonString === '{}' && Object.keys(obj).length > 0) {
                console.error('JSON.stringify produced empty object for:', obj);
                // Fallback: manually construct object
                if (Array.isArray(obj)) {
                  return obj.map(item => safeSerialize(item));
                } else {
                  const result = {};
                  for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                      result[key] = safeSerialize(obj[key]);
                    }
                  }
                  return result;
                }
              }
              return JSON.parse(jsonString);
            } catch (e) {
              console.error('JSON serialization failed for object:', obj, 'Error:', e);
              // Fallback: manually construct object
              if (Array.isArray(obj)) {
                return obj.map(item => safeSerialize(item));
              } else {
                const result = {};
                for (const key in obj) {
                  if (obj.hasOwnProperty(key)) {
                    try {
                      result[key] = safeSerialize(obj[key]);
                    } catch (e2) {
                      console.warn('Failed to serialize key', key, ':', e2);
                      result[key] = String(obj[key]);
                    }
                  }
                }
                return result;
              }
            }
          } catch (e) {
            console.error('Complete serialization failure for:', obj, e);
            return {};
          }
        }
        
        window.__TAURI__.core = {
          invoke: async function(cmd, args) {
            try {
              console.log('Browser invoke:', cmd, 'with args:', args);
              
              // Normalize arguments to a clean object
              const normalizedArgs = safeSerialize(args);
              console.log('Normalized args:', normalizedArgs);
              
              // Create a clean JSON string - bypass the problematic serialization
              let argsString;
              try {
                argsString = JSON.stringify(normalizedArgs);
                console.log('Args string:', argsString);
                
                // Check if we got empty objects when we shouldn't have
                if (argsString.includes('[{}') && normalizedArgs.tasks && normalizedArgs.tasks.length > 0) {
                  console.error('ðŸ”¥ DETECTED EMPTY OBJECTS IN JSON! Attempting direct serialization...');
                  console.log('Original tasks array:', normalizedArgs.tasks);
                  console.log('First task properties:', Object.getOwnPropertyNames(normalizedArgs.tasks[0]));
                  console.log('First task entries:', Object.entries(normalizedArgs.tasks[0]));
                  
                  // Try to manually serialize the tasks array
                  if (normalizedArgs.tasks) {
                    const manualTasks = normalizedArgs.tasks.map(task => {
                      console.log('Processing task:', task);
                      const obj = {};
                      
                      // Check if it's a Map (which is what WASM returns!)
                      if (task instanceof Map) {
                        console.log('ðŸŽ¯ FOUND THE PROBLEM: Task is a Map! Converting to Object...');
                        for (const [key, value] of task.entries()) {
                          obj[key] = value;
                          console.log(`Map entry: ${key} = ${value}`);
                        }
                      } else {
                        // Try different ways to copy properties for regular objects
                        try {
                          // Method 1: for...in loop
                          for (const key in task) {
                            if (task.hasOwnProperty(key)) {
                              obj[key] = task[key];
                              console.log(`Copied ${key}: ${task[key]}`);
                            }
                          }
                          
                          // Method 2: Object.keys if for...in didn't work
                          if (Object.keys(obj).length === 0) {
                            Object.keys(task).forEach(key => {
                              obj[key] = task[key];
                              console.log(`Keys method - copied ${key}: ${task[key]}`);
                            });
                          }
                          
                          // Method 3: Object.getOwnPropertyNames as last resort
                          if (Object.keys(obj).length === 0) {
                            Object.getOwnPropertyNames(task).forEach(key => {
                              obj[key] = task[key];
                              console.log(`PropertyNames method - copied ${key}: ${task[key]}`);
                            });
                          }
                        } catch (e) {
                          console.error('Manual copy failed:', e);
                        }
                      }
                      
                      console.log('Final copied object:', obj);
                      return obj;
                    });
                    
                    const manualArgs = {...normalizedArgs, tasks: manualTasks};
                    argsString = JSON.stringify(manualArgs);
                    console.log('âœ… Manual serialization result:', argsString);
                  }
                }
              } catch (e) {
                console.error('JSON.stringify failed:', e);
                argsString = '{}';
              }
              
              const payload = { 
                cmd, 
                args: normalizedArgs,
                args_string: argsString 
              };
              
              console.log('Sending payload:', payload);
              
              const res = await fetch('/api/invoke', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              
              if (!res.ok) {
                console.error('HTTP error:', res.status, res.statusText);
                return null;
              }
              
              const data = await res.json().catch(e => {
                console.error('JSON parse error:', e);
                return null;
              });
              
              console.log('Received response:', data);
              return data;
            } catch (e) {
              console.error('Invoke error:', e);
              return null;
            }
          }
        };
        // Provide a no-op event.listen for external HTTP pages to avoid capability errors in Tauri v2
        window.__TAURI__.event = window.__TAURI__.event || {};
        window.__TAURI__.event.listen = async function(_eventName, _handler) {
          return { unlisten() {} };
        };
      })();
    </script>
  </head>
  <body></body>
</html>
